/**
 *  Timed‑Rebeca version of the LF Raft benchmark (5 nodes)
 */

env int MSG_HEART       = -1;
env int MSG_ACK         = -2;
env int MSG_ELECTION    = -3;
env int MSG_VOTE        = -4;
env int MSG_LEADER      = -5;

env int TIMEOUT_MS_LOW  = 150;
env int TIMEOUT_MS_HIGH = 300;

env int FOLLOWER   		= 0;
env int CANDIDATE  		= 1;
env int LEADER     		= 2;

reactiveclass RaftNode(10) {

    knownrebecs {
        RaftNode n0;
        RaftNode n1;
        RaftNode n2;
        RaftNode n3;
        RaftNode n4;
    }

    statevars {
        int leader;				// who this node thinks is leader
        int election_timeout;	// in msec
        int term;
        int voted_for;
        int mode;				// FOLLOWER, LEADER, CANDIDATE

        int votes_received;

        /* ---- flattened input port in[i] : msg_t ---- */
        int  in_0_payload;   int in_0_term;   boolean in_0_is_present;
        int  in_1_payload;   int in_1_term;   boolean in_1_is_present;
        int  in_2_payload;   int in_2_term;   boolean in_2_is_present;
        int  in_3_payload;   int in_3_term;   boolean in_3_is_present;
        int  in_4_payload;   int in_4_term;   boolean in_4_is_present;

        /* ---- flattened output port out[i] : msg_t ---- */
        int  out_0_payload;  int out_0_term;
        int  out_1_payload;  int out_1_term;
        int  out_2_payload;  int out_2_term;
        int  out_3_payload;  int out_3_term;
        int  out_4_payload;  int out_4_term;

        /* ---- actions (logical‑time triggers) ---- */
        boolean election_timeout_reached_is_present;
        boolean start_election_is_present;
        
        // Used to model the behavior of a min. spacing of forever and the update policy.
        // In this case, an action only triggers a reaction when there are no other
        // such action scheduled in Rebeca's queue, i.e., this variable = 0.
        int election_timeout_reached_pending_count;
        

        /* ---- timers ---- */
        /* heartbeat is modelled as a timer‑driven msgsrv, period set in constructor */

        /* ---- multiple‑trigger bookkeeping ---- */
        boolean scheduled_reaction_1;
        boolean scheduled_reaction_2;
        boolean scheduled_reaction_3;
        boolean scheduled_reaction_4;
        boolean scheduled_reaction_5;
        boolean scheduled_reaction_6;
        boolean scheduled_reaction_7;
        boolean scheduled_reaction_8;
        boolean scheduled_reaction_9;
    }

    RaftNode(int id) {
    
        /* initialise “_is_present” flags */
        in_0_is_present = false;
        in_1_is_present = false;
        in_2_is_present = false;
        in_3_is_present = false;
        in_4_is_present = false;
        
        election_timeout_reached_is_present = false;
        start_election_is_present           = false;
        
        election_timeout_reached_pending_count 	= 0;
        
        scheduled_reaction_1 = false;
        scheduled_reaction_2 = false;
        scheduled_reaction_3 = false;
        scheduled_reaction_4 = false;
        scheduled_reaction_5 = false;
        scheduled_reaction_6 = false;
        scheduled_reaction_7 = false;
        scheduled_reaction_8 = false;
        scheduled_reaction_9 = false;

        // schedule the startup reaction immediately
        self.reaction_2();
    }
    
    // simple LCG random helper
    // FIXME: Non-det. choices do not work in methods.
    /*
    int rnGen() {
        election_timeout = (1664525 * election_timeout + 1013904223) & 0x7fffffff;
        election_timeout = ?(150, 300);
        return election_timeout;
    }
    */

    msgsrv random_int_in_range() {
        election_timeout = ?(150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300);
    }
  

	// Check if the action is updated. If so, cancel the current one.
    msgsrv lf_schedule_election_timeout_reached() {
    	// Since this msgsrv is triggered, decrement the count.
    	election_timeout_reached_pending_count--;
    	// Check if any is still pending, if so, don't do anything,
    	// i.e., canceling the stale event. Only trigger reactions
    	// when there are no actions pending. 
    	if (election_timeout_reached_pending_count == 0) {
    		election_timeout_reached_is_present = true;
	        // Trigger a reaction based on mode.
			if (mode == FOLLOWER) {
				self.reaction_4();
			} else if (mode == CANDIDATE) {
				self.reaction_9();
			}
    	}
    }

    msgsrv lf_schedule_start_election() {
        start_election_is_present = true;
        // TODO: Schedule a reaction based on mode.
        if (!scheduled_reaction_1) {
            scheduled_reaction_1 = true;
        }
    }

    msgsrv read_port_in0(int _payload, int _term) {
        in_0_payload    = _payload;
        in_0_term       = _term;
        in_0_is_present = true;

		// TODO: Schedule a reaction based on mode.
        if (!scheduled_reaction_1) {
            scheduled_reaction_1 = true;
        }
    }

    msgsrv reaction_1() {}
    
    msgsrv reaction_2() {
    	// Select election timeout
        self.random_int_in_range();
        
        // Track the number of lf_schedule_election_timeout_reached msgsrv enqueued.
        election_timeout_reached_pending_count++;
        // Schedule lf_schedule_election_timeout_reached.
        self.lf_schedule_election_timeout_reached() after(election_timeout);
    }
    
    msgsrv reaction_3() {}
    
    msgsrv reaction_4() {}
    
    msgsrv reaction_5() {}
    
    msgsrv reaction_6() {}
    
    msgsrv reaction_7() {}
    
    msgsrv reaction_8() {}
    
    msgsrv reaction_9() {}

    /* ---------- TO DEPRECATE: Main input‑driven reaction (Follower / Candidate / …) --*/
    /*
    @globalPriority(4)
    msgsrv reaction_inputs() {
        if (role == ROLE_FOLLOWER) {
            if (in_0_is_present && in_0_payload == MSG_HEART) {
                // heartbeat from leader 0
                term   = in_0_term;
                leader = 0;
                // respond ACK
                out_0_payload = MSG_ACK;  out_0_term = term;
                n0.read_port_in(out_0_payload, out_0_term) after(0);
                self.lf_schedule_election_timeout_reached() after(election_timeout);
            }
            else if (election_timeout_reached_is_present) {
                // convert to candidate
                role            = ROLE_CANDIDATE;
                votes_received  = 1;          // vote for self
                term           += 1;
                // broadcast election
                out_0_payload = MSG_ELECTION; out_0_term = term;
                // … repeat for peers
                n0.read_port_in(out_0_payload, out_0_term) after(0);
                n1.read_port_in(out_0_payload, out_0_term) after(0);
                n2.read_port_in(out_0_payload, out_0_term) after(0);
                n3.read_port_in(out_0_payload, out_0_term) after(0);
                n4.read_port_in(out_0_payload, out_0_term) after(0);

                // schedule new election timeout
                self.lf_schedule_election_timeout_reached() after(election_timeout);
            }
        }
        else if (role == ROLE_LEADER) {
            // handle ACKs, competing leaders, etc. — elided
        }
        else if (role == ROLE_CANDIDATE) {
            // count votes, step down, etc. — elided
        }

        self.reaction_inputs_postamble();
    }
    */

    /* ---------- Postamble (highest priority in class) ------------------*/
    @globalPriority(5)
    msgsrv reaction_inputs_postamble() {
        in_0_is_present = false;   in_1_is_present = false;   in_2_is_present = false;
        in_3_is_present = false;   in_4_is_present = false;
        election_timeout_reached_is_present = false;
        start_election_is_present          = false;
        scheduled_reaction_1             = false;
    }

    /* ---------- Timer‑driven heartbeat while we are leader -------------*/
    /*
    @globalPriority(4)
    msgsrv heartbeat() {
        if (role == ROLE_LEADER) {
            broadcast_heartbeat();
        }
        self.heartbeat() after(100);
    }
    */
}

/************************  STEP 9 – main block  *************************/
main {
    /* instantiate 5 Raft nodes and wire them in a full mesh            */
    RaftNode n0(n1,n2,n3,n4,n0):(0);
    RaftNode n1(n0,n2,n3,n4,n1):(1);
    RaftNode n2(n0,n1,n3,n4,n2):(2);
    RaftNode n3(n0,n1,n2,n4,n3):(3);
    RaftNode n4(n0,n1,n2,n3,n4):(4);
}
