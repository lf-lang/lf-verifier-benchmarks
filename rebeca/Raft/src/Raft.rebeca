/**
 *  Timed‑Rebeca version of the LF Raft benchmark (5 nodes)
 */

env int MSG_HEART       = -1;
env int MSG_ACK         = -2;
env int MSG_ELECTION    = -3;
env int MSG_VOTE        = -4;
env int MSG_LEADER      = -5;

env int TIMEOUT_MS_LOW  = 150;
env int TIMEOUT_MS_HIGH = 300;

env int FOLLOWER   		= 0;
env int CANDIDATE  		= 1;
env int LEADER     		= 2;

env int NUM_NODES		= 5;

reactiveclass RaftNode(10) {

    knownrebecs {
        RaftNode n0;
        RaftNode n1;
        RaftNode n2;
        RaftNode n3;
        RaftNode n4;
    }

    statevars {
        int bank_index;			// ID of this node
        int leader;				// who this node thinks is leader
        int election_timeout;	// in msec
        int term;
        int voted_for;
        int mode;				// FOLLOWER, LEADER, CANDIDATE
        int votes_received;

        int[5] in_type;
        int[5] in_term;
        boolean[5] in_is_present;
        
        int[5] out_type_value;
        int[5] out_term_value;
        
        // Scientific modeling of communication latencies
        int[5] latencies;

        /* ---- actions (logical‑time triggers) ---- */
        boolean election_timeout_reached_is_present;
        boolean start_election_is_present;
        
        // Used to model the behavior of a min. spacing of forever and the update policy.
        // In this case, an action only triggers a reaction when there are no other
        // such action scheduled in Rebeca's queue, i.e., this variable = 0.
        int election_timeout_reached_pending_count;

        /* ---- multiple‑trigger bookkeeping ---- */
        boolean scheduled_reaction_1;
        boolean scheduled_reaction_2;
        boolean scheduled_reaction_3;
        boolean scheduled_reaction_4;
        boolean scheduled_reaction_5;
        boolean scheduled_reaction_6;
        boolean scheduled_reaction_7;
        boolean scheduled_reaction_8;
        boolean scheduled_reaction_9;
    }

    RaftNode(int id) {
    	bank_index = id; // Remember the node's own ID.
    
        /* initialise “_is_present” flags */
        for (int i = 0; i < NUM_NODES; i++) {
        	in_is_present[i] = false;
        }
        
        election_timeout_reached_is_present = false;
        start_election_is_present           = false;
        
        election_timeout_reached_pending_count 	= 0;
        
        scheduled_reaction_1 = false;
        scheduled_reaction_2 = false;
        scheduled_reaction_3 = false;
        scheduled_reaction_4 = false;
        scheduled_reaction_5 = false;
        scheduled_reaction_6 = false;
        scheduled_reaction_7 = false;
        scheduled_reaction_8 = false;
        scheduled_reaction_9 = false;

        // schedule the startup reaction immediately
        self.reaction_2();
    }
    
    // FIXME: Non-det. choices do not work in methods.
    msgsrv randomize_election_timeout() {
        election_timeout = ?(150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300);
    }
    
    // SCIENTIFIC MODELING of communication latencies
    // Each element is the latency between the current node and a destination node.
    msgsrv randomize_latencies() {
    	for (int i = 0; i < NUM_NODES; i++) {
    		latencies[i] = ?(150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300);
    	}
    }
    
    msgsrv broadcast_message(int type) {
    
    	for (int i = 0; i < NUM_NODES; i++) {
    		out_type_value[i] = type;
    		out_term_value[i] = term;
    	}
    	
    	self.randomize_latencies();
    	
    	n0.read_port_in(bank_index, type, term) after(latencies[0]);
    	n1.read_port_in(bank_index, type, term) after(latencies[1]);
    	n2.read_port_in(bank_index, type, term) after(latencies[2]);
    	n3.read_port_in(bank_index, type, term) after(latencies[3]);
    	n4.read_port_in(bank_index, type, term) after(latencies[4]);
    }

	// Check if the action is updated. If so, cancel the current one.
    msgsrv lf_schedule_election_timeout_reached() {
    	// Since this msgsrv is triggered, decrement the count.
    	election_timeout_reached_pending_count--;
    	// Check if any is still pending, if so, don't do anything,
    	// i.e., canceling the stale event. Only trigger reactions
    	// when there are no actions pending. 
    	if (election_timeout_reached_pending_count == 0) {
    		election_timeout_reached_is_present = true;
	        // Trigger a reaction based on mode.
			if (mode == FOLLOWER) {
				self.reaction_4();
			} else if (mode == CANDIDATE) {
				self.reaction_9();
			}
    	}
    }

    msgsrv lf_schedule_start_election() {
        start_election_is_present = true;
        if (mode == CANDIDATE) {
        	self.reaction_7();
        }
    }

	// A parameterized read_port msgsrv for multiports
    msgsrv read_port_in(int chan, int _type, int _term) {
        in_type[chan]    	= _type;
        in_term[chan]       = _term;
        in_is_present[chan] = true;

		// TODO: Schedule a reaction based on mode.
        if (!scheduled_reaction_1) {
            scheduled_reaction_1 = true;
        }
    }

    msgsrv reaction_1() {}
    
    msgsrv reaction_2() {
    	// Select election timeout
        self.randomize_election_timeout();
        
        // Track the number of lf_schedule_election_timeout_reached msgsrv enqueued.
        election_timeout_reached_pending_count++;
        // Schedule lf_schedule_election_timeout_reached.
        self.lf_schedule_election_timeout_reached() after(election_timeout);
    }
    
    msgsrv reaction_3() {}
    
    msgsrv reaction_4() {
	    // In Rebeca, mode transition needs to happen before lf_schedule,
	    // so that reaction triggering works properly.
		mode = CANDIDATE;
		self.lf_schedule_start_election() after(0);
    }
    
    msgsrv reaction_5() {}
    
    msgsrv reaction_6() {}
    
    msgsrv reaction_7() {
    	// Increment its term id.
    	term++;
    	// Reset the vote count to 0.
    	// NOTE: This was a real bug, which could be a good test case for model checking.
    	votes_received = 0;
    	// Vote for itself.
    	voted_for = bank_index;
    	votes_received++;
    	// Broadcast an election start message.
    	self.broadcast_message(MSG_ELECTION);
    	// Schedule a timeout action to collect votes.
    	self.lf_schedule_election_timeout_reached() after(election_timeout);
    }
    
    msgsrv reaction_8() {}
    
    msgsrv reaction_9() {}

    // Postamble
    msgsrv reaction_inputs_postamble() {
        // TODO: Set input_is_present to false.
        election_timeout_reached_is_present = false;
        start_election_is_present          = false;
        scheduled_reaction_1             = false;
    }
}

main {
    /* instantiate 5 Raft nodes and wire them in a full mesh            */
    RaftNode n0(n1,n2,n3,n4,n0):(0);
    RaftNode n1(n0,n2,n3,n4,n1):(1);
    RaftNode n2(n0,n1,n3,n4,n2):(2);
    RaftNode n3(n0,n1,n2,n4,n3):(3);
    RaftNode n4(n0,n1,n2,n3,n4):(4);
}
