target C;

@lang("rust")
reactor Controller {
    input inp:i32
    output out1:i32
    output out2:i32
    output out3:i32
    logical action another(5 ms)
    reaction(startup, another) -> out1, out2, out3 {=
        ctx.set(out1, 1);
        ctx.set(out2, 2);
        ctx.set(out3, 3);
    =}
    reaction(inp) -> another {=
        ctx.schedule(another, 0);
    =}
}

@lang("c")
reactor Train {
    input inp:int
    output out:int
    state received:int
    reaction(inp) -> out {=
        self->received = inp->value;
        lf_set(out, self->received);
    =}
}

@lang("rust")
reactor Door {
    input inp:i32
    output out:i32
    state received:i32
    reaction(inp) -> out {=
        self.received = ctx.get(inp);
        ctx.set(out, self.received);
    =}
}

@lang("c")
reactor Sink {
    input in1:int
    input in2:int
    input in3:int
    output out:int
    state sum:int = 0
    reaction(in1, in2, in3) -> out {=
        self->sum = in1->value + in2->value + in3->value;
        lf_set(out, self->sum);
    =}
}

@property(name="train_does_not_move_until_door_closes", tactic="bmc", spec="(!TrainDoor.t.reaction_1)U[0, 1 sec](TrainDoor.d.reaction_1)", expect=false)
@lang("c")
main reactor {
    c = new Controller()
    t = new Train()
    d = new Door()
    d2 = new Door()
    s = new Sink()
    c.out1 -> t.inp after 1 sec
    c.out2 -> d.inp after 1 sec
    c.out3 -> d2.inp after 1 sec
    t.out -> s.in1
    d.out -> s.in2
    d2.out -> s.in3
    s.out -> c.inp
}